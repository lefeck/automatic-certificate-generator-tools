#!/bin/bash
#
set -Eeuo pipefail

function cleanup() {
        trap - SIGINT SIGTERM ERR EXIT
        if [ -n "${tmpdir+x}" ]; then
                rm -rf "$tmpdir" "$bootdir"
                log "üöΩ Deleted temporary working directory $tmpdir"
        fi
}

#trap cleanup SIGINT SIGTERM ERR EXIT

script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)
# check whether the date command-line tools exists
[[ ! -x "$(command -v date)" ]] && echo "üí• date command not found." && exit 1
today=$(date +"%Y-%m-%d")

function log() {
        echo >&2 -e "[$(date +"%Y-%m-%d %H:%M:%S")] ${1-}"
}

function die() {
        local msg=$1
        local code=${2-1} # Bash parameter expansion - default exit status 1. See https://wiki.bash-hackers.org/syntax/pe#use_a_default_value
        log "$msg"
        exit "$code"
}


usage() {
  cat << EOF
Usage: $(basename "${BASH_SOURCE[0]}") [-a [rsa|ecc]] [-d <domain>] [-n <name>] [-h]"

üíÅ This script will be automatic certificate genetatory.


Available options:

-a --algorithm         Algorithms supported by the issuing certificate tool. for example: rsa, ecc
-d --domain            The name of the domain name required to issue the certificate. for example: xxx.com, abc.org, *.abc.org
-n --name              Name of the file generated by the issuance certificate
-h --help              Print this help and exit
-v --verbose           Print script debug info
EOF
  exit
}

function parse_param() {
  DOMAIN_NAME=${DOMAIN_NAME:-domain.com}
  ALGORITHMS=${ALGORITHMS:-rsa}
  SRV_KEY_NAME=${SRV_KEY_NAME:-server}

    while getopts -o "a:d:n:h:v" -l algorithm:,domain:,name:,help:,verbose,  arg
    do
        case $arg in
            -a|--algorithm)
                ALGORITHMS=$OPTARG #ÁÆóÊ≥ï
                ;;
            -d|--domain)
                DOMAIN_NAME=$OPTARG
                ;;
            -n|--name)
                SRV_KEY_NAME=$OPTARG
                ;;
            -h|--help)
                usage
                ;;
            -v|--verbose)
                set -x
                ;;
            ?*) die "Unknown option: $1" ;;
            *) break ;;
                esac
                shift
    done
}

parse_param "$@"


get_domain="www:*.${DOMAIN_NAME},www:${DOMAIN_NAME}"
if [ -n "${DOMAIN_NAME}" ]; then
    # split domain name
    OLD_IFS="$IFS"
    IFS=","
    domain_array=(${DOMAIN_NAME})
    IFS="$OLD_IFS"

    domain_len=${#domain_array[@]}

    domain=${domain_array[0]}
    get_domain=""
    for ((i=0;i<domain_len;i++))
   {
    if [ $i = 0 ];then
        get_domain="www:${domain_array[i]}"
    else
        get_domain="${get_domain},www:${domain_array[i]}"
    fi
   }
   echo "${get_domain}"
fi

ca_subj="/C=CN/ST=Hubei/L=Wuhan/O=MY/CN=MY CA"
server_subj="/C=CN/ST=Hubei/L=Wuhan/O=MY/CN=${domain}"
#ÂÖ∂‰∏≠CÊòØCountryÔºåSTÊòØstateÔºåLÊòØlocalÔºåOÊòØOrganizationÔºåOUÊòØOrganization UnitÔºåCNÊòØcommon name
days=36500


certificate_dir="certs"
ca_key_file="${certificate_dir}/ca.key"
ca_crt_file="${certificate_dir}/ca.crt"
srv_key_file="${certificate_dir}/${SRV_KEY_NAME}.key"
srv_csr_file="${certificate_dir}/${SRV_KEY_NAME}.csr"
srv_crt_file="${certificate_dir}/${SRV_KEY_NAME}.crt"
srv_p12_file="${certificate_dir}/${SRV_KEY_NAME}.p12"
srv_pem_file="${certificate_dir}/${SRV_KEY_NAME}.pem"
srv_der_file="${certificate_dir}/${SRV_KEY_NAME}.der"
srv_fullchain_file="${certificate_dir}/${SRV_KEY_NAME}-fullchain.crt"
cfg_domain_file="${certificate_dir}/domain.cnf"


#algorithm config
if [[ ${ALGORITHMS} = "rsa" ]] ; then
    rsa_len=2048
elif [[ ${ALGORITHMS} = "ecc" ]] ; then
    ecc_name=prime256v1
else
    usage
    exit 1
fi     #ifend

echo "algorithm:${ALGORITHMS}"

mkdir -p ${certificate_dir} || true

function generate_ca_cert_file() {
    if [ ! -f "${ca_key_file}" ]; then
        log  "------------- generate ca key-----------------------"
        if [[ ${ALGORITHMS} = "rsa" ]] ; then
            openssl genrsa -out ${ca_key_file} ${rsa_len}
        elif [[ ${ALGORITHMS} = "ecc" ]] ; then
            openssl ecparam -out ${ca_key_file} -name ${ecc_name} -genkey
        fi

        openssl req -new -x509 -days ${days} -key ${ca_key_file} -out ${ca_crt_file} -subj "${ca_subj}"
        log "generate ca certificate file."
    fi
}

generate_ca_cert_file

function generate_server_key_and_crt_file() {
    if [ ! -f "${srv_key_file}" ]; then
        echo  "------------- generate server key-----------------------"
        if [[ ${ALGORITHMS} = "rsa" ]] ; then
            openssl genrsa -out ${srv_key_file} ${rsa_len}
        elif [[ ${ALGORITHMS} = "ecc" ]] ; then
            openssl ecparam -genkey -name ${ecc_name} -out ${srv_key_file}
        fi

        openssl req -new  -sha256 -key ${srv_key_file} -out ${srv_csr_file} -subj "${server_subj}"

        printf "[ SAN ]\nauthorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment\nsubjectAltName=${get_domain}" > ${cfg_domain_file}
        openssl x509 -req  -days ${days} -sha256 -CA ${ca_crt_file} -CAkey ${ca_key_file} -CAcreateserial -in ${srv_csr_file}  -out ${srv_crt_file} -extfile ${cfg_domain_file} -extensions SAN
        cat ${srv_crt_file} ${ca_crt_file} > ${srv_fullchain_file}

        openssl pkcs12 -export -inkey ${srv_key_file} -in ${srv_crt_file} -CAfile ${ca_crt_file} -chain -out ${srv_p12_file}
        # Convert CRT to PEM
        openssl x509 -in ${srv_crt_file} -out ${srv_pem_file}
        # Convert PEM to DER
        openssl x509 -outform der -in ${srv_pem_file} -out ${srv_der_file}
    fi
}

generate_server_key_and_crt_file
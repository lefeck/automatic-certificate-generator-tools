#!/bin/bash
#
set -Eeuo pipefail

trap  - SIGINT SIGTERM ERR EXIT

script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)
# check whether the date command-line tools exists
[[ ! -x "$(command -v date)" ]] && echo "üí• date command not found." && exit 1

function log() {
        echo >&2 -e "[$(date +"%Y-%m-%d %H:%M:%S")] ${1-}"
}

function die() {
        local msg=$1
        local code=${2-1} # Bash parameter expansion - default exit status 1. See https://wiki.bash-hackers.org/syntax/pe#use_a_default_value
        log "$msg"
        exit "$code"
}


function usage() {
  cat << EOF
Usage: $(basename "${BASH_SOURCE[0]}") [-a [rsa|ecc]] [-d <domain>] [-n <name>] [-t <days>] [-p <password>] [-s <show>] [-l <length>] [-h] [-v]"

üíÅ This script will be automatic certificate genetatory.


Available options:

-a --algorithm         Algorithms supported by the issuing certificate tool. for example: rsa, ecc, default the algorithm is "rsa".
-d --domain            The name of the domain name required to issue the certificate. for example: xxx.com, abc.org, *.abc.org, default the domain name is "domain.com".
-n --name              Name of the file generated by the issuance certificate, default the name is "server".
-t --days              Set the expiration time of the certificate, default the value is "3650" days.
-p --password          Set password for service certificate, default the password is random strings.
-s --show              Whether to display the service certificate password in the foreground, By default it will write to the .password file, if it is true it will output
                       the plaintext password in the foreground.
-l --length            Set password of the length, default the password length is 8 digits, This parameter and the -p option cannot be used together.
-h --help              Print this help and exit
-v --verbose           Print script debug info
EOF
  exit
}

function generate_random_pwd() {
    length=${length}
    i=1

    seq=(0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)

    num_seq=${#seq[@]}

    while [ "$i" -le "$length" ]
    do
     seqrand[$i]=${seq[$((RANDOM%num_seq))]}
     let "i=i+1"
    done
    random_str=$(IFS=; echo "${seqrand[*]}")
}



function parse_param() {
    length=${length:-8}
    # if arguement is empty, have a default value
    domain_name=${domain_name:-domain.com}
    algorithm=${algorithm:-rsa}
    srv_key_name=${srv_key_name:-server}
    days=${days:-3650}
    show=${show:-"false"}
    # parse argument of the command
    getopt_cmd=$(getopt -o a:d:n:t:p:l:shv --long algorithm:,domain:,name:,days:,password:,length:,show,help,verbose -n $(basename $0) -- "$@")
    if [ $? -ne 0 ]; then
        exit 1
    fi
    eval set -- "$getopt_cmd"
    while [ -n "$1" ]; do
        case "$1" in
                -a|--algorithm)
                    algorithm="$2"
                    shift ;;
                -d|--domain)
                    domain_name="$2"
                    shift ;;
                -n|--name)
                    srv_key_name="$2"
                    shift ;;
                -t|--time)
                    days="$2"
                    shift ;;
                -p|--password)
                    password="$2"
                    shift ;;
                -l|--length)
                    length="$2"
                    shift ;;
                -s|--show)
                    show="true"
                    ;;
                -h|--help)
                    usage
                    ;;
                -v|--verbose)
                    set -x
                    ;;
                --) shift
                    break ;;
                ?*) echo "$1 is not an option"
                    exit 1 ;;
        esac
        shift
    done

   generate_random_pwd
   password=${password:-${random_str}}
}

parse_param "$@"



get_domain="DNS:*.${domain_name},DNS:${domain_name}"
if [ -n "${domain_name}" ]; then
    # split domain name
    OLD_IFS="$IFS"
    IFS=","
    # shellcheck disable=SC2206
    domain_array=(${domain_name})
    IFS="$OLD_IFS"

    domain_len=${#domain_array[@]}

    domain=${domain_array[0]}
    get_domain=""
    for ((i=0;i<domain_len;i++))
   {
    if [ $i = 0 ];then
        get_domain="DNS:${domain_array[i]}"
    else
        get_domain="${get_domain},DNS:${domain_array[i]}"
    fi
   }
fi

ca_subj="/C=CN/ST=Hubei/L=Wuhan/O=MY/CN=MY CA"
server_subj="/C=CN/ST=Hubei/L=Wuhan/O=MY/CN=${domain}"
# where, the C is CountryÔºåthe ST is stateÔºåthe L is localÔºåthe O is OrganizationÔºåthe OU is Organization UnitÔºåthe CN is common name


# The default create a a random directory in /tmp
certificate_dir=$(mktemp -d)
if [[ ! "${certificate_dir}" || ! -d "${certificate_dir}" ]]; then
        die "üí• Could not create temporary working directory."
else
        log "üìÅ Created temporary working directory $certificate_dir"
fi

ca_key_file="${certificate_dir}/ca.key"
ca_crt_file="${certificate_dir}/ca.crt"
srv_key_file="${certificate_dir}/${srv_key_name}.key"
srv_csr_file="${certificate_dir}/${srv_key_name}.csr"
srv_crt_file="${certificate_dir}/${srv_key_name}.crt"
srv_p12_file="${certificate_dir}/${srv_key_name}.p12"
srv_pem_file="${certificate_dir}/${srv_key_name}.pem"
srv_der_file="${certificate_dir}/${srv_key_name}.der"
srv_pfx_file="${certificate_dir}/${srv_key_name}.pfx"
srv_fullchain_file="${certificate_dir}/${srv_key_name}-fullchain.crt"
cfg_san_file="${certificate_dir}/san.cnf"


# algorithm config
function get_algorithm() {
    if [[ ${algorithm} = "rsa" ]] ; then
        rsa_len=2048
    elif [[ ${algorithm} = "ecc" ]] ; then
        ecc_name=prime256v1
    else
        usage
    fi
}

# generate ca certificate file
function generate_ca_cert_file() {
    get_algorithm
    if [ ! -f "${ca_key_file}" ]; then
        log  "üëç generate ca certificate file"
        if [[ ${algorithm} = "rsa" ]] ; then
            openssl genrsa -out ${ca_key_file} ${rsa_len}
        elif [[ ${algorithm} = "ecc" ]] ; then
            openssl ecparam -out ${ca_key_file} -name ${ecc_name} -genkey
        fi
        openssl req -new -x509 -days ${days} -key ${ca_key_file} -out ${ca_crt_file} -subj "${ca_subj}"
        if [ $? -eq 0 ]; then
            log "üëç generate ca certificate file."
        else
            die "üí• generate ca certificate file failed, execute command found error."
        fi
    fi
}

# Generate server certificate key and crt file
function generate_server_key_and_crt_file() {
    generate_ca_cert_file
    if [ ! -f "${srv_key_file}" ]; then
        log  "üëç generate server key and crt file"
        if [[ ${algorithm} = "rsa" ]] ; then
            openssl genrsa -out ${srv_key_file} ${rsa_len}
        elif [[ ${algorithm} = "ecc" ]] ; then
            openssl ecparam -genkey -name ${ecc_name} -out ${srv_key_file}
        fi
        log "üëç genetate server key file"

        openssl req -new  -sha256 -key ${srv_key_file} -out ${srv_csr_file} -subj "${server_subj}"
        log "üëç genetate server certificate issuance request file"

        printf "[ SAN ]\nauthorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment\nsubjectAltName=${get_domain}" > ${cfg_san_file}
        openssl x509 -req  -days ${days} -sha256 -CA ${ca_crt_file} -CAkey ${ca_key_file} -CAcreateserial -in ${srv_csr_file}  -out ${srv_crt_file} -extfile ${cfg_san_file} -extensions SAN > /dev/null 2>&1
        log "üëç genetate server certificate file"

        cat ${srv_crt_file} ${ca_crt_file} > ${srv_fullchain_file}
        log "üëç genetate server fullchain file"

        openssl pkcs12 -export -inkey ${srv_key_file} -in ${srv_crt_file} -CAfile ${ca_crt_file} -chain -passout pass:${password} -out ${srv_p12_file}
        #openssl rsa -in private.key -aes256 -passout pass:1234 -out private_pwd.pem
        if [ ${show} == "true" ]; then
          log "üëç The certificate server password is ${password}"
        else
          printf "certificate password: ${password}\n" > "${certificate_dir}/.password"
          log "üëç The certificate password is in ${certificate_dir}/.password file"
        fi

        log "üëç certificate format convert CRT to P12"
        # Convert CRT to PEM
        openssl x509 -in ${srv_crt_file} -out ${srv_pem_file}
        log "üëç certificate format convert CRT to PEM"
        # Convert PEM to DER
        openssl x509 -outform der -in ${srv_pem_file} -out ${srv_der_file}
        log "üëç certificate format convert PEM to DER"
        # Convert CRT to PFX
        openssl pkcs12 -inkey ${srv_key_file} -in ${srv_crt_file} -export -passout pass:${password} -out ${srv_pfx_file}
        log "üëç certificate format convert CRT to PFX"
    fi
}
generate_server_key_and_crt_file
log "üëç all of the files generated in the $certificate_dir directory"
die "‚úÖ Completed." 0